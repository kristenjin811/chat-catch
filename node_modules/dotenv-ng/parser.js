"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnvFileParser = exports.DEFAULT_OPTIONS = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const debug = require("debug");
const log = debug("dotenv-ng:parser");
exports.DEFAULT_OPTIONS = {
    ignoreLiteralCase: true,
    parseLiterals: true,
    parseNumbers: true,
    allowEmptyVariables: true,
    allowOrphanKeys: false,
    interpolationEnabled: true,
    overwriteExisting: false,
};
function splitToLines(s) {
    return s.split(/\r?\n\r?/g);
}
class EmptyParserRule {
    condition(value) {
        log("EmptyParserRule:condition(value: %s)", value);
        return value === "";
    }
    parse() {
        log("EmptyParserRule:parse()");
        return "";
    }
}
class NumberParseRule {
    prepare(value) {
        log("NumberParseRule:prepare(value: %s)", value);
        return value.replace(NumberParseRule.NUMBER_LITERAL_SEPARATORS, "");
    }
    condition(value, options) {
        log("NumberParseRule:condition(value: %s, options: %o)", value, options);
        const prepared = this.prepare(value);
        return options.parseNumbers && prepared && !isNaN(+prepared);
    }
    parse(value) {
        log("NumberParseRule:parse(value: %s)", value);
        return +this.prepare(value);
    }
}
NumberParseRule.NUMBER_LITERAL_SEPARATORS = /[_\s]/g;
class StringLiteralParser {
    condition(value) {
        log("StringLiteralParser:condition(value: %s)", value);
        return StringLiteralParser.STRING_LITERAL.test(value);
    }
    parse(value) {
        log("StringLiteralParser:parse(value: %s)", value);
        return value.match(StringLiteralParser.STRING_LITERAL)[2];
    }
}
StringLiteralParser.STRING_LITERAL = /^(['"])(.*)\1$/;
class JSLiteralParser {
    prepare(value, options) {
        log("JSLiteralParser:prepare(value: %s, options: %o)", value, options);
        return options.ignoreLiteralCase ? value.toLowerCase() : value;
    }
    condition(value, options) {
        log("JSLiteralParser:condition(value: %s, options: %o)", value, options);
        return options.parseLiterals && this.prepare(value, options) in JSLiteralParser.JS_LITERALS;
    }
    parse(value, options) {
        log("JSLiteralParser:parse(value: %s, options: %o)", value, options);
        return JSLiteralParser.JS_LITERALS[this.prepare(value, options)];
    }
}
JSLiteralParser.JS_LITERALS = {
    "null": null,
    "undefined": undefined,
    "true": true,
    "false": false,
    "nan": NaN,
    "NaN": NaN,
};
class MissingKeyError extends Error {
    constructor() {
        super(...arguments);
        this.CODE = "MISSING_KEY";
    }
}
class OrphanKeyError extends Error {
    constructor() {
        super(...arguments);
        this.CODE = "ORPHAN_KEY";
    }
}
class EmptyVariableError extends Error {
    constructor() {
        super(...arguments);
        this.CODE = "EMPTY_VARIABLE";
    }
}
class EnvFileParser {
    constructor() {
        this.options = exports.DEFAULT_OPTIONS;
    }
    setOptions(options) {
        log("setOptions(options: %o)", options);
        this.options = Object.assign(Object.assign({}, exports.DEFAULT_OPTIONS), options);
    }
    static isCommentLine(line) {
        log("isCommentLine(line: %s)", line);
        return EnvFileParser.COMMENT_LINE.test(line);
    }
    static parseLine(line) {
        const [, key, assignment, value] = line.match(EnvFileParser.VARIABLE_LINE);
        log("parseLine(line: %s) -> { key: %s, assignment: %s, value: %s }", line, key, assignment, value);
        return { key, assignment, value };
    }
    static interpolateValue(key, value, values) {
        log("interpolateValue(key: %s, value: %s, values: %o)", key, value, values);
        return value.replace(EnvFileParser.INTERPOLATION, (m, k) => {
            log("interpolateValue -> replace(m: %s, k: %s)", m, k);
            if (key !== k && k in values) {
                return String(values[k]);
            }
            return m;
        });
    }
    getInterpolatedEnv(values) {
        log("getInterpolatedEnv(values: %o, overwrite: %b)", values, this.options.overwriteExisting);
        return this.options.overwriteExisting
            ? Object.assign(Object.assign({}, process.env), values) : Object.assign(Object.assign({}, values), process.env);
    }
    intepolateValues(values) {
        log("intepolateValues(values: %o, overwrite: %b)", values, this.options.overwriteExisting);
        for (const key in values) {
            const value = values[key];
            if (typeof value === "string") {
                const sourceValues = this.getInterpolatedEnv(values);
                values[key] = EnvFileParser.interpolateValue(key, value, sourceValues);
            }
        }
        return values;
    }
    parseValue(value) {
        log("parseValue(value: %s)", value);
        for (const rule of EnvFileParser.rules) {
            if (rule.condition(value, this.options)) {
                return rule.parse(value, this.options);
            }
        }
        log("parseValue -> %s", value);
        return value;
    }
    parse(path) {
        log("parse(path: %s)", path);
        if (!(0, fs_1.existsSync)(path)) {
            throw new Error(`Path does not exist: ${path}!`);
        }
        if ((0, fs_1.statSync)(path).isFile()) {
            return this.parseFile(path);
        }
        if ((0, fs_1.statSync)(path).isDirectory()) {
            const paths = [
                (0, path_1.join)(path, ".env"),
                (0, path_1.join)(path, ".env.local"),
            ];
            if (this.options.environment) {
                paths.splice(1, 0, (0, path_1.join)(path, `.env.${this.options.environment}`));
            }
            log("parse -> paths: %o", paths);
            let folderResults = {
                data: {},
                errors: [],
            };
            for (const p of paths) {
                try {
                    const results = this.parseFile(p);
                    log("parse -> parsed: %s", p);
                    folderResults = {
                        data: Object.assign(Object.assign({}, folderResults.data), results.data),
                        errors: [
                            ...folderResults.errors,
                            ...results.errors,
                        ]
                    };
                }
                catch (e) {
                    log("parse -> error: %s", e);
                    // missing file
                }
            }
            return folderResults;
        }
        throw new Error(`Invalid path: ${path}!`);
    }
    parseLine(line) {
        log("parseLine(line: %s)", line);
        if (EnvFileParser.isCommentLine(line)) {
            return;
        }
        const { key, assignment, value } = EnvFileParser.parseLine(line);
        if (!key) {
            throw new MissingKeyError();
        }
        const trimmedKey = key.trim();
        if (!assignment && !this.options.allowOrphanKeys) {
            throw new OrphanKeyError();
        }
        const trimmedValue = value.trim();
        if (!trimmedValue && !this.options.allowEmptyVariables) {
            throw new EmptyVariableError();
        }
        return [trimmedKey, this.parseValue(trimmedValue)];
    }
    parseString(content, path) {
        log("parseString(content: %s, path: %s)", content, path);
        const lines = splitToLines(content);
        log("parseString -> lines: %d", lines.length);
        const results = {
            data: {},
            errors: [],
        };
        for (let i = 0; i < lines.length; ++i) {
            const line = lines[i];
            log("parseString -> line %d: %s", i + 1, line);
            try {
                const result = this.parseLine(line);
                if (result) {
                    results.data[result[0]] = result[1];
                }
            }
            catch (e) {
                results.errors.push({
                    file: path,
                    line: i + 1,
                    error: e.CODE,
                    data: line,
                });
            }
        }
        results.data = this.intepolateValues(results.data);
        log("parseString -> %o", results);
        return results;
    }
    parseFile(path) {
        log("parseFile(path: %s)", path);
        return this.parseString((0, fs_1.readFileSync)(path, { encoding: "utf-8" }));
    }
}
exports.EnvFileParser = EnvFileParser;
EnvFileParser.rules = [
    new EmptyParserRule(),
    new NumberParseRule(),
    new StringLiteralParser(),
    new JSLiteralParser(),
];
EnvFileParser.COMMENT_LINE = /^\s*#/i;
EnvFileParser.VARIABLE_LINE = /^\s*(?:export\s+)?([^=]*)\s*(=)?(.*?)(?:#|$)/i;
EnvFileParser.INTERPOLATION = /\$\{(.*?)\}/;
const parser = new EnvFileParser();
exports.default = parser;
//# sourceMappingURL=parser.js.map